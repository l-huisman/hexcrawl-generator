<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexcrawl Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=UnifrakturCook:wght@700&display=swap" rel="stylesheet">
    <style>
        body { font-family: Arial, sans-serif; background: #f4f4f4; margin: 0; padding: 0; }
        .container { max-width: 800px; margin: 40px auto; background: #fff; padding: 24px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1 { text-align: center; font-family: 'UnifrakturCook', cursive; font-size: 2.5em; letter-spacing: 2px; }
        #hex-map { margin: 32px 0; display: flex; justify-content: center; }
        .placeholder { color: #888; text-align: center; }
        #hex-legend { text-align: center; margin: 10px 0 0 0; }
        #hex-legend span { display: inline-block; width: 18px; height: 18px; border: 1px solid #555; margin-right: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hexcrawl Generator</h1>
        <div id="hex-map">
            <canvas id="hex-canvas" width="600" height="520" style="background:#e9ecef; border-radius:8px;"></canvas>
        </div>
        <div id="controls" style="text-align:center;">
            <label>Rows: <input id="rows-input" type="number" min="2" max="40" value="7" style="width:3em;"></label>
            <label>Cols: <input id="cols-input" type="number" min="2" max="40" value="8" style="width:3em;"></label>
            <label>Hex Size: <input id="size-input" type="number" min="10" max="60" value="36" style="width:3em;"></label>
            <button id="generate-btn">Generate Hex Map</button>
            <button id="player-map-btn">Player Map</button>
            <button id="dm-map-btn">DM Map</button>
            <button id="back-btn" style="display:none;">Back to Overworld</button>
            <button id="force-generate-btn" style="display:none;">Force Generate Island</button>
        </div>
        <div id="hex-legend">
            <span style="background:#f7e9a0;"></span> Sand
            <span style="background:#7bb661;"></span> Forest
            <span style="background:#e2e2a0;"></span> Grassland
            <span style="background:#b0b0b0;"></span> Mountain
            <span style="background:#d94f2a;"></span> Volcano
            <span style="background:#bfa76f;"></span> Outpost
            <span style="background:#6b3fa0;"></span> Dungeon
            <span style="background:#7ec8e3;"></span> Water
        </div>
    </div>
    <script>
        function randomTerrain() {
            // Only one type of island
            return { name: 'Island', color: '#e2e2a0' };
        }

        function drawHex(ctx, x, y, size, fillColor, label) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const px = x + size * Math.cos(angle);
                const py = y + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = fillColor;
            ctx.fill();
            // No label/text drawn
        }

        // Store hex map state
        let hexMap = [];
        let currentHex = { row: 3, col: 4 }; // Start near center for 7x8 grid
        let visited = new Set();
        let revealed = new Set(); // Track all revealed (current + ring) hexes

        function revealRing(row, col, rows, cols) {
            revealed.add(row + ',' + col);
            for (let n of getNeighbors(row, col, rows, cols)) {
                revealed.add(n.row + ',' + n.col);
            }
        }

        // Helper: hex distance for flat-topped hexes
        function hexDistance(a, b) {
            // Convert offset coords to cube coords
            function toCube(row, col) {
                let x = col - (row - (row&1)) / 2;
                let z = row;
                let y = -x - z;
                return {x, y, z};
            }
            const ac = toCube(a.row, a.col);
            const bc = toCube(b.row, b.col);
            return Math.max(Math.abs(ac.x - bc.x), Math.abs(ac.y - bc.y), Math.abs(ac.z - bc.z));
        }

        function generateHexMap(rows, cols) {
            hexMap = [];
            for (let row = 0; row < rows; row++) {
                let rowArr = [];
                for (let col = 0; col < cols; col++) {
                    rowArr.push({ terrain: { name: 'Water', color: '#7ec8e3' }, row, col });
                }
                hexMap.push(rowArr);
            }
            // Natural island spawn: random clusters, but still separated
            let islandCount = Math.max(2, Math.floor((rows * cols) / 18));
            let placed = [];
            let attempts = 0;
            while (placed.length < islandCount && attempts < 4000) {
                let row = Math.floor(Math.random() * rows);
                let col = Math.floor(Math.random() * cols);
                // Try to cluster some islands, but keep min distance for most
                let minDist = Math.random() < 0.4 ? 3 : 8; // 40% chance to allow closer (clustered) islands
                let tooClose = placed.some(p => hexDistance(p, {row, col}) < minDist);
                let adjacent = placed.some(p => hexDistance(p, {row, col}) === 1);
                if (!tooClose && !adjacent) {
                    hexMap[row][col].terrain = randomTerrain();
                    placed.push({row, col});
                }
                attempts++;
                if (attempts > 2000 && placed.length < islandCount) break;
            }
            // Move player to a random island
            let playerIsland = placed[Math.floor(Math.random() * placed.length)];
            currentHex = { row: playerIsland.row, col: playerIsland.col };
            visited = new Set();
            revealed = new Set();
            visited.add(currentHex.row + ',' + currentHex.col);
            revealRing(currentHex.row, currentHex.col, rows, cols);
        }

        function getNeighbors(row, col, rows, cols) {
            // Flat-topped hexes, even-q column offset
            // Directions: E, NE, NW, W, SW, SE
            const even = col % 2 === 0;
            const directions = even
                ? [[-1,0],[-1,1],[0,1],[1,0],[0,-1],[-1,-1]]
                : [[-1,0],[0,1],[1,1],[1,0],[1,-1],[0,-1]];
            let neighbors = [];
            for (let [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                if (r >= 0 && r < rows && c >= 0 && c < cols) {
                    neighbors.push({ row: r, col: c });
                }
            }
            return neighbors;
        }

        // Overworld draw
        function drawHexGrid(rows, cols, size, revealAll = false) {
            resizeCanvas(rows, cols, size);
            const canvas = document.getElementById('hex-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const w = 2 * size;
            const h = Math.sqrt(3) * size;
            const gridWidth = (cols - 1) * 1.5 * size + w;
            const gridHeight = h * rows;
            const xOffset = (canvas.width - gridWidth) / 2 + size;
            const yOffset = (canvas.height - gridHeight) / 2 + h / 2;
            let visible = new Set();
            if (!revealAll) {
                visible.add(currentHex.row + ',' + currentHex.col);
                for (let n of getNeighbors(currentHex.row, currentHex.col, rows, cols)) {
                    visible.add(n.row + ',' + n.col);
                }
            }
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = xOffset + col * 1.5 * size;
                    const y = yOffset + row * h + (col % 2) * (h / 2);
                    const hex = hexMap[row][col];
                    let key = row + ',' + col;
                    let isCurrent = (row === currentHex.row && col === currentHex.col);
                    let isVisible = revealAll ? true : visible.has(key);
                    let isRevealed = revealAll ? true : revealed.has(key);
                    let fill = hex.terrain.color;
                    let label = isCurrent ? 'You' : hex.terrain.name;
                    let alpha = 1;
                    if (isVisible) {
                        alpha = 1;
                    } else if (isRevealed) {
                        alpha = 0.4;
                    } else {
                        fill = '#e9ecef';
                        label = '';
                        alpha = 1;
                    }
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    drawHex(ctx, x, y, size, fill, label);
                    ctx.restore();
                }
            }
        }

        // Helper to get grid params from UI
        function getGridParams() {
            const rows = parseInt(document.getElementById('rows-input').value, 10);
            const cols = parseInt(document.getElementById('cols-input').value, 10);
            const size = parseInt(document.getElementById('size-input').value, 10);
            return { rows, cols, size };
        }

        // Helper to resize canvas based on grid size
        function resizeCanvas(rows, cols, size) {
            const canvas = document.getElementById('hex-canvas');
            const w = (cols - 1) * 1.5 * size + 2 * size + 20; // add margin
            const h = Math.sqrt(3) * size * rows + Math.sqrt(3) * size + 20; // add margin
            canvas.width = Math.ceil(w);
            canvas.height = Math.ceil(h);
        }

        // State for overworld and island
        let overworldState = null;
        let inIslandView = false;

        function saveOverworldState(rows, cols, size) {
            overworldState = {
                hexMap: JSON.parse(JSON.stringify(hexMap)),
                revealed: new Set([...revealed]),
                visited: new Set([...visited]),
                currentHex: { ...currentHex },
                rows, cols, size
            };
        }
        function restoreOverworldState() {
            if (!overworldState) return;
            hexMap = JSON.parse(JSON.stringify(overworldState.hexMap));
            revealed = new Set([...overworldState.revealed]);
            visited = new Set([...overworldState.visited]);
            currentHex = { ...overworldState.currentHex };
            drawHexGrid(overworldState.rows, overworldState.cols, overworldState.size);
        }

        // Island terrain types
        function randomIslandTerrain(type) {
            if (type === 'center') return { name: 'Mountain', color: '#b0b0b0' };
            if (type === 'volcano') return { name: 'Volcano', color: '#d94f2a' };
            if (type === 'town') return { name: 'Outpost', color: '#bfa76f' };
            if (type === 'beach') return { name: 'Sand', color: '#f7e9a0' };
            if (type === 'forest') return { name: 'Forest', color: '#388e3c' };
            if (type === 'mountain') return { name: 'Mountain', color: '#b0b0b0' };
            if (type === 'dungeon') return { name: 'Dungeon', color: '#6b3fa0' };
            return { name: 'Grassland', color: '#b6e36b' }; // brighter, more visible grass
        }

        // Store generated islands by overworld hex key
        let islandMaps = {};

        function getIslandKey(row, col) {
            return row + ',' + col;
        }

        // Add a legend for island terrain
        function drawLegend() {
            let legend = document.getElementById('hex-legend');
            if (!legend) {
                legend = document.createElement('div');
                legend.id = 'hex-legend';
                legend.style.textAlign = 'center';
                legend.style.margin = '10px 0 0 0';
                document.querySelector('.container').appendChild(legend);
            }
            legend.innerHTML = `
                <span style="display:inline-block;width:18px;height:18px;background:#f7e9a0;border:1px solid #555;margin-right:4px;"></span> Sand
                <span style="display:inline-block;width:18px;height:18px;background:#7bb661;border:1px solid #555;margin:0 4px 0 16px;"></span> Forest
                <span style="display:inline-block;width:18px;height:18px;background:#e2e2a0;border:1px solid #555;margin:0 4px 0 16px;"></span> Grassland
                <span style="display:inline-block;width:18px;height:18px;background:#b0b0b0;border:1px solid #555;margin:0 4px 0 16px;"></span> Mountain
                <span style="display:inline-block;width:18px;height:18px;background:#d94f2a;border:1px solid #555;margin:0 4px 0 16px;"></span> Volcano
                <span style="display:inline-block;width:18px;height:18px;background:#bfa76f;border:1px solid #555;margin:0 4px 0 16px;"></span> Outpost
                <span style="display:inline-block;width:18px;height:18px;background:#6b3fa0;border:1px solid #555;margin:0 4px 0 16px;"></span> Dungeon
                <span style="display:inline-block;width:18px;height:18px;background:#7ec8e3;border:1px solid #555;margin:0 4px 0 16px;"></span> Water
            `;
        }

        function generateIslandMapForKey(key) {
            // Vary the island grid size and edge parameters for more size variance
            let size = 13;
            // 10% small, 20% large, 70% medium
            let gridType = Math.random();
            let rows, cols, edgeBase;
            if (gridType < 0.1) { // small
                rows = cols = 13;
                edgeBase = 4.5 + Math.random();
            } else if (gridType > 0.9) { // large
                rows = cols = 25;
                edgeBase = 9 + Math.random() * 1.5;
            } else { // medium
                rows = cols = 19;
                edgeBase = 6.5 + Math.random() * 1.5;
            }
            const center = { row: Math.floor(rows/2), col: Math.floor(cols/2) };
            let mainIsland;
            let attempts = 0;
            do {
                // Generate a blobby mask using cellular automata
                let mask = Array.from({length: rows}, () => Array(cols).fill(0));
                // Seed center and fewer random points for less land
                mask[center.row][center.col] = 1;
                for (let i = 0; i < 30; i++) {
                    let angle = Math.random() * 2 * Math.PI;
                    let r = center.row + Math.round(Math.sin(angle) * (3 + Math.random() * (rows/3)));
                    let c = center.col + Math.round(Math.cos(angle) * (3 + Math.random() * (cols/3)));
                    if (r > 1 && r < rows-2 && c > 1 && c < cols-2) mask[r][c] = 1;
                }
                // Grow the island, more steps, looser rules
                for (let step = 0; step < 7; step++) {
                    let newMask = mask.map(arr => arr.slice());
                    for (let row = 1; row < rows-1; row++) {
                        for (let col = 1; col < cols-1; col++) {
                            let count = 0;
                            for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                                if (mask[row+dr][col+dc]) count++;
                            }
                            if (mask[row][col]) {
                                if (count < 2) newMask[row][col] = 0;
                            } else {
                                if (count > 2) newMask[row][col] = 1;
                            }
                        }
                    }
                    mask = newMask;
                }
                // Add organic edge: shrink mask with angle-based noise, more aggressive edge
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if (!mask[row][col]) continue;
                        let dx = col - center.col;
                        let dy = row - center.row;
                        let dist = Math.sqrt(dx*dx + dy*dy);
                        let angle = Math.atan2(dy, dx);
                        let edge = edgeBase + Math.sin(angle * 2 + Math.random() * 2) * 2.5 + Math.cos(angle * 3 + Math.random()) * 2.5;
                        if (dist > edge) mask[row][col] = 0;
                    }
                }
                // Flood fill from center to keep only the largest contiguous landmass
                let visited = Array.from({length: rows}, () => Array(cols).fill(false));
                let queue = [[center.row, center.col]];
                mainIsland = Array.from({length: rows}, () => Array(cols).fill(0));
                while (queue.length) {
                    let [r, c] = queue.pop();
                    if (r < 0 || r >= rows || c < 0 || c >= cols) continue;
                    if (visited[r][c] || !mask[r][c]) continue;
                    visited[r][c] = true;
                    mainIsland[r][c] = 1;
                    for (let [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1],[-1,1],[1,-1]]) {
                        queue.push([r+dr, c+dc]);
                    }
                }
                attempts++;
                // If the center is not land, try again (max 10 attempts)
            } while (!mainIsland[center.row][center.col] && attempts < 10);
            // Assign terrain types with improved logic
            let map = [];
            let volcanoCount = 0;
            let maxVolcano = Math.random() < 0.5 ? 0 : (Math.random() < 0.7 ? 1 : 2);
            let volcanoLocations = [];
            // Forest cluster mask
            let forestMask = Array.from({length: rows}, () => Array(cols).fill(false));
            let forestCenters = [];
            let forestClusterCount = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < forestClusterCount; i++) {
                let tries = 0;
                while (tries < 20) {
                    let r = center.row + Math.floor(Math.random() * Math.floor(rows/2)) - Math.floor(rows/4);
                    let c = center.col + Math.floor(Math.random() * Math.floor(cols/2)) - Math.floor(cols/4);
                    if (r > 2 && r < rows-3 && c > 2 && c < cols-3 && mainIsland[r][c]) {
                        forestCenters.push({r, c});
                        break;
                    }
                    tries++;
                }
            }
            for (let fc of forestCenters) {
                for (let dr = -2; dr <= 2; dr++) {
                    for (let dc = -2; dc <= 2; dc++) {
                        let rr = fc.r + dr, cc = fc.c + dc;
                        if (rr >= 0 && rr < rows && cc >= 0 && cc < cols && mainIsland[rr][cc]) {
                            let dist = Math.abs(dr) + Math.abs(dc);
                            if (dist <= 2 && Math.random() < 0.7 - 0.15 * dist) {
                                forestMask[rr][cc] = true;
                            }
                        }
                    }
                }
            }
            // First pass: assign volcanoes and record their locations
            let volcanoMask = Array.from({length: rows}, () => Array(cols).fill(false));
            for (let row = 1; row < rows-1; row++) {
                for (let col = 1; col < cols-1; col++) {
                    let dist = hexDistance(center, {row, col});
                    if (mainIsland[row][col] && volcanoCount < maxVolcano && dist <= 2 && Math.random() < 0.18) {
                        // Check if all 6 adjacent hexes are land and not volcano
                        let canPlace = true;
                        let hexDirs = [[-1,0],[0,1],[1,1],[1,0],[0,-1],[-1,-1]];
                        for (let [dr, dc] of hexDirs) {
                            let rr = row + dr, cc = col + dc;
                            if (!mainIsland[rr][cc] || volcanoMask[rr][cc]) {
                                canPlace = false;
                                break;
                            }
                        }
                        if (canPlace) {
                            volcanoMask[row][col] = true;
                            volcanoLocations.push({row, col});
                            volcanoCount++;
                            // Surround volcano with mountains
                            for (let [dr, dc] of hexDirs) {
                                let rr = row + dr, cc = col + dc;
                                if (mainIsland[rr][cc] && !volcanoMask[rr][cc]) {
                                    mountainMask[rr][cc] = true;
                                }
                            }
                        }
                    }
                }
            }
            // Find outpost candidates: land hexes adjacent to at least one water hex, not within 2 hexes of a volcano, and not surrounded by water
            let outpostCandidates = [];
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (!mainIsland[row][col]) continue;
                    // Check neighbors for water and land
                    let waterNeighbors = 0;
                    let landNeighbors = 0;
                    for (let [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1],[-1,1],[1,-1]]) {
                        let rr = row + dr, cc = col + dc;
                        if (rr >= 0 && rr < rows && cc >= 0 && cc < cols) {
                            if (!mainIsland[rr][cc]) waterNeighbors++;
                            else landNeighbors++;
                        }
                    }
                    // Check distance to all volcanoes
                    let tooCloseToVolcano = volcanoLocations.some(v => hexDistance({row, col}, v) < 2);
                    // Require at least 2 sea and at least 3 land neighbors
                    if (waterNeighbors >= 2 && landNeighbors >= 3 && !tooCloseToVolcano) outpostCandidates.push({row, col});
                }
            }
            // Randomly pick one outpost candidate (70% chance to have an outpost)
            let outpostLoc = null;
            if (outpostCandidates.length && Math.random() < 0.7) {
                outpostLoc = outpostCandidates[Math.floor(Math.random() * outpostCandidates.length)];
            }
            // Mountain range logic: place 1-3 mountain ranges, each 3-6 hexes long, snaking from a random land hex
            let mountainRanges = [];
            let mountainMask = Array.from({length: rows}, () => Array(cols).fill(false));
            let numRanges = 1 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numRanges; i++) {
                let tries = 0;
                let start = null;
                while (tries < 30) {
                    let r = Math.floor(Math.random() * rows);
                    let c = Math.floor(Math.random() * cols);
                    if (mainIsland[r][c] && !mountainMask[r][c]) {
                        start = {r, c};
                        break;
                    }
                    tries++;
                }
                if (!start) continue;
                let length = 3 + Math.floor(Math.random() * 4);
                let dir = Math.floor(Math.random() * 6); // 6 hex directions
                let r = start.r, c = start.c;
                for (let j = 0; j < length; j++) {
                    if (r < 0 || r >= rows || c < 0 || c >= cols) break;
                    if (!mainIsland[r][c]) break;
                    mountainMask[r][c] = true;
                    // Move in a random direction (with some bias to keep snaking)
                    let dirs = [[-1,0],[0,1],[1,1],[1,0],[0,-1],[-1,-1]];
                    let d = (dir + Math.floor(Math.random()*3)-1 + 6) % 6;
                    r += dirs[d][0];
                    c += dirs[d][1];
                }
            }
            // Dungeon logic: 5% chance to spawn a dungeon in a random land hex (not volcano, not outpost)
            let dungeonLoc = null;
            if (Math.random() < 0.05) {
                let candidates = [];
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if (mainIsland[row][col] && !volcanoMask[row][col]) {
                            candidates.push({row, col});
                        }
                    }
                }
                if (candidates.length) {
                    dungeonLoc = candidates[Math.floor(Math.random() * candidates.length)];
                }
            }
            for (let row = 0; row < rows; row++) {
                let rowArr = [];
                for (let col = 0; col < cols; col++) {
                    let dist = hexDistance(center, {row, col});
                    let t;
                    if (!mainIsland[row][col]) {
                        t = { name: 'Water', color: '#7ec8e3' };
                    } else if (dungeonLoc && row === dungeonLoc.row && col === dungeonLoc.col) {
                        t = randomIslandTerrain('dungeon');
                    } else if (outpostLoc && row === outpostLoc.row && col === outpostLoc.col) {
                        t = randomIslandTerrain('town');
                    } else if (volcanoMask[row][col]) {
                        t = randomIslandTerrain('volcano');
                    } else if (mountainMask[row][col]) {
                        t = randomIslandTerrain('mountain');
                    } else if (dist <= 2 && Math.random() < 0.25) {
                        t = randomIslandTerrain('mountain');
                    } else if (forestMask[row][col]) {
                        t = randomIslandTerrain('forest');
                    } else if (dist >= Math.floor(rows/4) && dist <= Math.floor(rows/2.7)) {
                        t = randomIslandTerrain('beach');
                    } else if (dist <= Math.floor(rows/3)) {
                        t = randomIslandTerrain('grass');
                    } else {
                        t = randomIslandTerrain('beach');
                    }
                    rowArr.push({ terrain: t, row, col });
                }
                map.push(rowArr);
            }
            return map;
        }

        function generateIslandMap(key) {
            let rows = 19, cols = 19, size = 13;
            if (!islandMaps[key]) {
                islandMaps[key] = generateIslandMapForKey(key);
            }
            hexMap = JSON.parse(JSON.stringify(islandMaps[key]));
            revealed = new Set();
            visited = new Set();
            const center = { row: Math.floor(rows/2), col: Math.floor(cols/2) };
            currentHex = { row: center.row, col: center.col };
            revealed.add(currentHex.row + ',' + currentHex.col);
            drawHexGrid(rows, cols, size, true);
            drawLegend();
        }

        function updateControls() {
            const inIsland = inIslandView;
            document.getElementById('back-btn').style.display = inIsland ? '' : 'none';
            document.getElementById('player-map-btn').style.display = inIsland ? 'none' : '';
            document.getElementById('dm-map-btn').style.display = inIsland ? 'none' : '';
            document.getElementById('generate-btn').style.display = inIsland ? 'none' : '';
            document.getElementById('rows-input').style.display = inIsland ? 'none' : '';
            document.getElementById('cols-input').style.display = inIsland ? 'none' : '';
            document.getElementById('size-input').style.display = inIsland ? 'none' : '';
            document.getElementById('force-generate-btn').style.display = inIsland ? '' : 'none';
        }

        // Click handler for entering island view
        document.getElementById('hex-canvas').addEventListener('click', function(e) {
            if (inIslandView) return; // ignore in island view
            const { rows, cols, size } = getGridParams();
            const canvas = this;
            const rect = canvas.getBoundingClientRect();
            const w = 2 * size;
            const h = Math.sqrt(3) * size;
            const gridWidth = (cols - 1) * 1.5 * size + w;
            const gridHeight = h * rows;
            const xOffset = (canvas.width - gridWidth) / 2 + size;
            const yOffset = (canvas.height - gridHeight) / 2 + h / 2;
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const hx = xOffset + col * 1.5 * size;
                    const hy = yOffset + row * h + (col % 2) * (h / 2);
                    const dx = x - hx;
                    const dy = y - hy;
                    if (Math.abs(dx) < size && Math.abs(dy) < h / 2) {
                        let key = row + ',' + col;
                        let neighbors = getNeighbors(currentHex.row, currentHex.col, rows, cols).map(n => n.row + ',' + n.col);
                        // If clicking on current island, enter island view
                        if (row === currentHex.row && col === currentHex.col && hexMap[row][col].terrain.name === 'Island') {
                            saveOverworldState(rows, cols, size);
                            inIslandView = true;
                            updateControls();
                            document.getElementById('back-btn').style.display = '';
                            generateIslandMap(key);
                            return;
                        }
                        if (neighbors.includes(key)) {
                            currentHex = { row, col };
                            visited.add(key);
                            revealRing(row, col, rows, cols);
                            drawHexGrid(rows, cols, size);
                        }
                        return;
                    }
                }
            }
        });
        // Back to overworld
        document.getElementById('back-btn').addEventListener('click', function() {
            inIslandView = false;
            updateControls();
            document.getElementById('back-btn').style.display = 'none';
            restoreOverworldState();
        });

        document.getElementById('generate-btn').addEventListener('click', function() {
            const { rows, cols, size } = getGridParams();
            currentHex = { row: Math.floor(rows/2), col: Math.floor(cols/2) };
            generateHexMap(rows, cols);
            drawHexGrid(rows, cols, size);
            updateControls();
        });
        document.getElementById('player-map-btn').addEventListener('click', function() {
            const { rows, cols, size } = getGridParams();
            drawHexGrid(rows, cols, size, false);
            updateControls();
        });
        document.getElementById('dm-map-btn').addEventListener('click', function() {
            const { rows, cols, size } = getGridParams();
            drawHexGrid(rows, cols, size, true);
            updateControls();
        });
        document.getElementById('force-generate-btn').addEventListener('click', function() {
            if (inIslandView) {
                // Regenerate and display the current island
                const key = currentHex.row + ',' + currentHex.col;
                islandMaps[key] = generateIslandMapForKey(key); // force new map
                // Use the same logic as generateIslandMap but don't cache
                let rows = islandMaps[key].length;
                let cols = islandMaps[key][0].length;
                let size = 13;
                hexMap = JSON.parse(JSON.stringify(islandMaps[key]));
                revealed = new Set();
                visited = new Set();
                const center = { row: Math.floor(rows/2), col: Math.floor(cols/2) };
                currentHex = { row: center.row, col: center.col };
                revealed.add(currentHex.row + ',' + currentHex.col);
                drawHexGrid(rows, cols, size, true);
                drawLegend();
            }
        });
        // Initial map
        (function() {
            const { rows, cols, size } = getGridParams();
            currentHex = { row: Math.floor(rows/2), col: Math.floor(cols/2) };
            generateHexMap(rows, cols);
            drawHexGrid(rows, cols, size);
            updateControls();
        })();
    </script>
</body>
</html>
